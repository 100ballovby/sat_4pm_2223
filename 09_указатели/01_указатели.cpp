#include <iostream>
using namespace std;

void address_ptr() {  // адрес ячейки переменной
    int b = 8;
    int arr[3] = {0, 0, 0};
    /* При выполнении этого кода процессор
     * выделяет в оперативной памяти место под
     * переменную b (под то значение, которое в
     * ней хранится) */
    cout << "Адрес переменной b: " << &b << endl;
    cout << "Адрес первого элемента массива arr: " << &arr << " адрес второго: " << &arr[1] << endl;
    // & - оператор адреса, который позволяет узнать номер ячейке определенной переменной
}

void pointers() {  // указатели
    int b = 8;  // переменная
    int *c = &b;  // указатель (ссылка) на ячейку, присвоенную b (c = 8)

    // * - оператор разыменовывания позволяет получить значение по адресу
    cout << "Разыменованый адрес - *&b: " << *&b << endl;
    cout << "На что ссылается указатель c: " << c << endl;
    cout << "Значение указателя *c: " << *c << endl;
    /* В первом случае звездочку не ставим, потому что
     * хотим вывести адрес, на который указывает c (указатель с),
     * Во втором случае звездочка нужна, чтобы получить значение,
     * на которое ссылается указатель с. */

    /* изменить значение, на которое ссылается указатель,
    можно только путем изменения значения переменной,
    на которую он указывает */
    b = b + 1;
    cout << *c << endl;
    /* Указатель - это переменная, значение которой является
     * адресом ячейки памяти. Указатели объявляются так же,
     * как обычные переменные, но СО ЗВЕЗДОЧКОЙ МЕЖДУ ИМЕНЕМ
     * И ТИПОМ ДАННЫХ */
}

void how_to_write_pointer() {
    /* Как объявлять указатели.
     * ПРАВИЛО - пишите звездочку рядом с именем указателя */
    int *iPtr;  // так можно - объявил целочисленный указатель iPtr
    double *dPtr;  // так можно - объявил вещественный указатель dPtr

    int* iPtr2;  // допустимо, но лучше так не делать
    double * dPtr2;  // допустимо, но лучше так не делать

    int *iPtr3, *iPtr4, *iPtr5;  // можно объявлять сразу несколько указателей
    double *dPtr3, dPtr4;  // dPtr3 - указатель, dPtr4 - обычная переменная
}

void pointers_usage() {
    int b = 8;
    int *ptr = &b;  // создал целочисленный указатель на адрес ячейки b
    cout << "&b: " << &b << endl;
    cout << "ptr: " << ptr << endl;

    // int *ptr2 = 8;  <- у числа 8 нет адреса, соответственно указатель на нее сделать нельзя
    // int *ptr2 = b;  <- ссылаться можно ТОЛЬКО на адреса. Ссылка на переменную невозможна
}

void dynamic_array() {
    /* чтобы создать динамический массив, нужно написать его имя как указатель
 * и в качестве значения поставить тип данных с ключевым словом new */
    int count;
    cout << "Введи количество: ";
    cin >> count;

    int *scores = new int[count]; // объявление динамического массива
    for (int i = 0; i < count; i++) {  // наполним динамический массив числами
        cout << "Элемент №" << i + 1 << ": ";
        cin >> scores[i];
    }

    // ДИНАМИЧЕСКИЕ РАСШИРЯТЬ НЕЛЬЗЯ
    for (int i = 0; i < count; i++) {
        cout << scores[i] << ", ";
    }
    /* После динамического выделения памяти
     * порядочные программисты ее очищают.
     * Чтобы удалить динамический массив,
     * можно использовать ключевое слово delete
     * или просто присвоить массиву нулевой указатель */

    delete[] scores;  // удалил массив
    scores = nullptr; // присвоил нулевой указатель. можно вместо нулевого указателя написать 0

}